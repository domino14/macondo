package cross_set

import (
	"github.com/domino14/macondo/board"
	"github.com/domino14/macondo/gaddag"
	"github.com/domino14/macondo/move"
	"github.com/domino14/macondo/tinymove"
	"github.com/domino14/word-golib/tilemapping"
)

type CrossSet = board.CrossSet
type Board = board.GameBoard

const (
	Left       = board.LeftDirection
	Right      = board.RightDirection
	Horizontal = board.HorizontalDirection
	Vertical   = board.VerticalDirection
)

type GenericMove interface {
	PlayLength() int
}

// Public cross_set.Generator Interface
// There are two concrete implementations below,
// - CrossScoreOnlyGenerator{Dist}
// - GaddagCrossSetGenerator{Dist, Gaddag}

type Generator interface {
	Generate(b *Board, row int, col int, dir board.BoardDirection)
	GenerateAll(b *Board)
	UpdateForMove(b *Board, m *move.Move)
	UpdateForSmallMove(b *Board, m *tinymove.SmallMove, moveTiles *[board.MaxBoardDim]tilemapping.MachineLetter)
}

// generateAll generates all cross-sets. It goes through the entire
// board; our anchor algorithm doesn't quite match the one in the Gordon
// paper.
// We do this for both transpositions of the board.
func generateAll(g Generator, b *Board) {
	n := b.Dim()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			g.Generate(b, i, j, Horizontal)
		}
	}
	b.Transpose()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			g.Generate(b, i, j, Vertical)
		}
	}
	// And transpose back to the original orientation.
	b.Transpose()
}

// Assumes all across words are HORIZONTAL.
func calcForAcross(rowStart int, colStart int, csd board.BoardDirection,
	g Generator, m *move.Move, b *Board) {

	// log.Debug().Msgf("Updating for move: %s", m.ShortDescription())
	for row := rowStart; row < m.PlayLength()+rowStart; row++ {
		if m.Tiles()[row-rowStart] == 0 {
			// No new "across word" was generated by this tile, so no need
			// to update cross set.
			continue
		}
		// Otherwise, look along this row. Note, the edge is still part
		// of the word.
		rightCol := b.WordEdge(int(row), int(colStart), Right)
		leftCol := b.WordEdge(int(row), int(colStart), Left)
		g.Generate(b, int(row), int(rightCol)+1, csd)
		g.Generate(b, int(row), int(leftCol)-1, csd)
		// This should clear the cross set on the just played tile.
		g.Generate(b, int(row), int(colStart), csd)
	}
}

func calcForAcrossSmall(rowStart int, colStart int, csd board.BoardDirection,
	g Generator, m *tinymove.SmallMove, b *Board, moveTiles *[board.MaxBoardDim]tilemapping.MachineLetter) {

	// log.Debug().Msgf("Updating for move: %s", m.ShortDescription())
	for row := rowStart; row < m.PlayLength()+rowStart; row++ {
		if moveTiles[row-rowStart] == 0 {
			// No new "across word" was generated by this tile, so no need
			// to update cross set.
			continue
		}
		// Otherwise, look along this row. Note, the edge is still part
		// of the word.
		rightCol := b.WordEdge(int(row), int(colStart), Right)
		leftCol := b.WordEdge(int(row), int(colStart), Left)
		g.Generate(b, int(row), int(rightCol)+1, csd)
		g.Generate(b, int(row), int(leftCol)-1, csd)
		// This should clear the cross set on the just played tile.
		g.Generate(b, int(row), int(colStart), csd)
	}
}

// assumes self is HORIZONTAL
func calcForSelf(rowStart int, colStart int, csd board.BoardDirection,
	g Generator, m GenericMove, b *Board) {
	// Generate cross-sets on either side of the word.
	for col := int(colStart) - 1; col <= int(colStart)+m.PlayLength(); col++ {
		g.Generate(b, int(rowStart), col, csd)
	}
}

func updateForMove(g Generator, b *Board, m *move.Move) {

	// log.Trace().Msgf("Updating for move: %s", m.ShortDescription())
	row, col, vertical := m.CoordsAndVertical()
	// Every tile placed by this new move creates new "across" words, and we need
	// to update the cross sets on both sides of these across words, as well
	// as the cross sets for THIS word.

	if vertical {
		calcForAcross(row, col, Horizontal, g, m, b)
		b.Transpose()
		row, col = col, row
		calcForSelf(row, col, Vertical, g, m, b)
		b.Transpose()
	} else {
		calcForSelf(row, col, Horizontal, g, m, b)
		b.Transpose()
		row, col = col, row
		calcForAcross(row, col, Vertical, g, m, b)
		b.Transpose()
	}
}

func updateForSmallMove(g Generator, b *Board, m *tinymove.SmallMove, moveTiles *[board.MaxBoardDim]tilemapping.MachineLetter) {
	row, col, vertical := m.CoordsAndVertical()
	// Every tile placed by this new move creates new "across" words, and we need
	// to update the cross sets on both sides of these across words, as well
	// as the cross sets for THIS word.

	if vertical {
		calcForAcrossSmall(row, col, Horizontal, g, m, b, moveTiles)
		b.Transpose()
		row, col = col, row
		calcForSelf(row, col, Vertical, g, m, b)
		b.Transpose()
	} else {
		calcForSelf(row, col, Horizontal, g, m, b)
		b.Transpose()
		row, col = col, row
		calcForAcrossSmall(row, col, Vertical, g, m, b, moveTiles)
		b.Transpose()
	}
}

// ----------------------------------------------------------------------
// Use a CrossScoreOnlyGenerator when you don't need cross sets

type CrossScoreOnlyGenerator struct {
	Dist *tilemapping.LetterDistribution
}

func (g *CrossScoreOnlyGenerator) Generate(b *Board, row int, col int, dir board.BoardDirection) {
	genCrossScore(b, row, col, dir, g.Dist)
}

func (g *CrossScoreOnlyGenerator) GenerateAll(b *Board) {
	generateAll(g, b)
}

func (g *CrossScoreOnlyGenerator) UpdateForMove(b *Board, m *move.Move) {
	updateForMove(g, b, m)
}

func (g *CrossScoreOnlyGenerator) UpdateForSmallMove(b *Board, m *tinymove.SmallMove, n *[board.MaxBoardDim]tilemapping.MachineLetter) {
	panic("UpdateForSmallMove should never be called with CrossScoreOnlyGenerator")
}

// Wrapper functions to save rewriting all the tests

func GenAllCrossScores(b *Board, ld *tilemapping.LetterDistribution) {
	gen := CrossScoreOnlyGenerator{Dist: ld}
	gen.GenerateAll(b)
}

// ----------------------------------------------------------------------
// Implementation for CrossScoreOnlyGenerator

func genCrossScore(b *Board, row int, col int, dir board.BoardDirection,
	ld *tilemapping.LetterDistribution) {
	if row < 0 || row >= b.Dim() || col < 0 || col >= b.Dim() {
		return
	}
	// If the square has a letter in it, its cross set and cross score
	// should both be 0
	if b.HasLetter(row, col) {
		b.SetCrossScore(row, col, 0, dir)
		return
	}
	// If there's no tile adjacent to this square in any direction,
	// every letter is allowed.
	if b.LeftAndRightEmpty(row, col) {
		b.SetCrossScore(row, col, 0, dir)
		return
	}
	// If we are here, there is a letter to the left, to the right, or both.
	// start from the right and go backwards.
	rightCol := b.WordEdge(row, col+1, Right)
	if rightCol == col {
		score := b.TraverseBackwardsForScore(row, col-1, ld)
		b.SetCrossScore(row, col, score, dir)
	} else {
		// Otherwise, the right is not empty. Check if the left is empty,
		// if so we just traverse right, otherwise, we try every letter.
		scoreR := b.TraverseBackwardsForScore(row, rightCol, ld)
		scoreL := b.TraverseBackwardsForScore(row, col-1, ld)
		b.SetCrossScore(row, col, scoreR+scoreL, dir)
	}
}

// ----------------------------------------------------------------------
// GaddagCrossSetGenerator generates cross sets via a gaddag

type GaddagCrossSetGenerator struct {
	Dist   *tilemapping.LetterDistribution
	Gaddag gaddag.WordGraph
}

func (g *GaddagCrossSetGenerator) Generate(b *Board, row int, col int, dir board.BoardDirection) {
	GenCrossSet(b, row, col, dir, g.Gaddag, g.Dist)
}

func (g *GaddagCrossSetGenerator) GenerateAll(b *Board) {
	generateAll(g, b)
}

func (g *GaddagCrossSetGenerator) UpdateForMove(b *Board, m *move.Move) {
	updateForMove(g, b, m)
}

func (g *GaddagCrossSetGenerator) UpdateForSmallMove(b *Board, m *tinymove.SmallMove, moveTiles *[board.MaxBoardDim]tilemapping.MachineLetter) {
	updateForSmallMove(g, b, m, moveTiles)
}

// Wrapper functions to save rewriting all the tests

func GenAllCrossSets(b *Board, gd gaddag.WordGraph, ld *tilemapping.LetterDistribution) {
	gen := GaddagCrossSetGenerator{Dist: ld, Gaddag: gd}
	gen.GenerateAll(b)
}

func UpdateCrossSetsForMove(b *Board, m *move.Move,
	gd gaddag.WordGraph, ld *tilemapping.LetterDistribution) {
	gen := GaddagCrossSetGenerator{Dist: ld, Gaddag: gd}
	gen.UpdateForMove(b, m)
}

// ----------------------------------------------------------------------
// Implementation for GaddagCrossSetGenerator

func traverseBackwards(b *Board, row int, col int,
	nodeIdx uint32, checkLetterSet bool, leftMostCol int,
	gaddag gaddag.WordGraph) (uint32, bool) {
	// Traverse the letters on the board backwards (left). Return the index
	// of the node in the gaddag for the left-most letter, and a boolean
	// indicating if the gaddag path was valid.
	// If checkLetterSet is true, then we traverse until leftMostCol+1 and
	// check the letter set of this node to see if it includes the letter
	// at leftMostCol
	for b.PosExists(row, col) {
		ml := b.GetLetter(row, col)
		if ml == 0 {
			break
		}

		if checkLetterSet && col == leftMostCol {
			if gaddag.InLetterSet(ml, nodeIdx) {
				return nodeIdx, true
			}
			// Give up early; if we're checking letter sets we only care about
			// this column.
			return nodeIdx, false
		}

		nodeIdx = gaddag.NextNodeIdx(nodeIdx, ml.Unblank())
		if nodeIdx == 0 {
			// There is no path in the gaddag for this word part; this
			// can occur if a phony was played and stayed on the board
			// and the phony has no extensions for example, or if it's
			// a real word with no further extensions.
			return nodeIdx, false
		}

		col--
	}

	return nodeIdx, true
}

// GenCrossSet generates a cross-set and extension sets for each individual square.
// Extension sets (leftx/rightx) indicate which letters can extend plays in each direction.
// These are used for shadow-based move generation to enable early pruning.
func GenCrossSet(b *Board, row int, col int, dir board.BoardDirection,
	gd gaddag.WordGraph, ld *tilemapping.LetterDistribution) {

	if row < 0 || row >= b.Dim() || col < 0 || col >= b.Dim() {
		return
	}

	// Extension sets are stored for the SAME direction as the cross-set direction.
	// When we're generating cross-sets for direction D, we're looking at words
	// perpendicular to D. But the extension sets should tell us what letters
	// can extend plays in direction D (NOT the perpendicular direction).
	// This is because extension sets are used during movegen in direction D.
	//
	// For horizontal plays (stored in hLeftExtSets), we need extension sets
	// computed from the horizontal word structure, which happens when we
	// process with dir=Horizontal.
	throughDir := dir

	// If the square has a letter in it, its cross set and cross score
	// should both be 0
	if b.HasLetter(row, col) {
		b.ClearCrossSet(row, col, dir)
		b.SetCrossScore(row, col, 0, dir)
		return
	}
	// If there's no tile adjacent to this square in any direction,
	// every letter is allowed.
	if b.LeftAndRightEmpty(row, col) {
		b.SetCrossSet(row, col, board.TrivialCrossSet, dir)
		b.SetCrossScore(row, col, 0, dir)
		return
	}

	// If we are here, there is a letter to the left, to the right, or both.
	// Find the word edges.
	leftCol := b.WordEdge(row, col-1, Left)
	rightCol := b.WordEdge(row, col+1, Right)
	nonemptyToLeft := leftCol < col
	nonemptyToRight := rightCol > col

	// Track extension sets for leftside and rightside tiles
	var leftsideLeftxSet, leftsideRightxSet uint64
	var rightsideLeftxSet, rightsideRightxSet uint64
	var backHookSet, frontHookSet uint64

	if nonemptyToLeft {
		// Traverse the left side tiles to get the node index
		lNodeIdx, lPathValid := traverseBackwards(b, row, col-1,
			gd.GetRootNodeIndex(), false, 0, gd)

		if lPathValid {
			// Get the extension sets from this node
			_, leftsideLeftxSet = gaddag.GetLetterAndExtensionSets(gd, lNodeIdx)

			// Get the back hook set (letters that can go after the left-side word)
			// by following the separation token
			sIdx := gd.NextNodeIdx(lNodeIdx, 0)
			if sIdx != 0 {
				backHookSet, leftsideRightxSet = gaddag.GetLetterAndExtensionSets(gd, sIdx)
			}
		}

		// Set extension sets on the rightmost tile of the left-side word (col-1)
		b.SetLeftExtSetWithBlank(row, col-1, throughDir, leftsideLeftxSet)
		b.SetRightExtSetWithBlank(row, col-1, throughDir, leftsideRightxSet)

		// Also set the leftx on the empty square to the left of the left-side tiles
		// This helps move gen avoid dead ends
		if leftCol > 0 {
			b.SetLeftExtSetWithBlank(row, leftCol-1, throughDir, leftsideLeftxSet)
		}
	}

	if nonemptyToRight {
		// Traverse the right side tiles to get the node index
		rNodeIdx, rPathValid := traverseBackwards(b, row, rightCol,
			gd.GetRootNodeIndex(), false, 0, gd)

		if rPathValid {
			// Get the front hook set (letters that can go before the right-side word)
			frontHookSet, rightsideLeftxSet = gaddag.GetLetterAndExtensionSets(gd, rNodeIdx)

			// Get rightside rightx by following the separation token
			sIdx := gd.NextNodeIdx(rNodeIdx, 0)
			if sIdx != 0 {
				_, rightsideRightxSet = gaddag.GetLetterAndExtensionSets(gd, sIdx)
			}
		}

		// Set extension sets on the leftmost tile of the right-side word (rightCol)
		b.SetLeftExtSetWithBlank(row, rightCol, throughDir, rightsideLeftxSet)
		b.SetRightExtSetWithBlank(row, rightCol, throughDir, rightsideRightxSet)

		// Set the leftx on this empty square (for rightside tiles)
		b.SetLeftExtSetWithBlank(row, col, throughDir, rightsideLeftxSet)
	}

	// Now compute the cross-set for this empty square
	if !nonemptyToRight {
		// Only tiles to the left
		score := b.TraverseBackwardsForScore(row, col-1, ld)
		b.SetCrossScore(row, col, score, dir)

		lNodeIdx, lPathValid := traverseBackwards(b, row, col-1,
			gd.GetRootNodeIndex(), false, 0, gd)
		if !lPathValid {
			b.SetCrossSet(row, col, 0, dir)
			return
		}
		sIdx := gd.NextNodeIdx(lNodeIdx, 0)
		letterSet := gd.GetLetterSet(sIdx)
		b.SetCrossSet(row, col, CrossSet(letterSet), dir)
	} else if !nonemptyToLeft {
		// Only tiles to the right
		scoreR := b.TraverseBackwardsForScore(row, rightCol, ld)
		b.SetCrossScore(row, col, scoreR, dir)

		rNodeIdx, rPathValid := traverseBackwards(b, row, rightCol,
			gd.GetRootNodeIndex(), false, 0, gd)
		if !rPathValid {
			b.SetCrossSet(row, col, 0, dir)
			return
		}
		letterSet := gd.GetLetterSet(rNodeIdx)
		b.SetCrossSet(row, col, CrossSet(letterSet), dir)
	} else {
		// Tiles on both sides - need to find letters that connect them
		scoreR := b.TraverseBackwardsForScore(row, rightCol, ld)
		scoreL := b.TraverseBackwardsForScore(row, col-1, ld)
		b.SetCrossScore(row, col, scoreR+scoreL, dir)

		// Start from the right and try each letter that could connect
		rNodeIdx, rPathValid := traverseBackwards(b, row, rightCol,
			gd.GetRootNodeIndex(), false, 0, gd)
		if !rPathValid {
			b.SetCrossSet(row, col, 0, dir)
			return
		}

		b.SetCrossSet(row, col, 0, dir)
		for i := rNodeIdx; ; i++ {
			t := gd.Tile(i)
			if t != 0 {
				// Only try letters that are possible in right extensions
				// from the left side (optimization from Magpie)
				if leftsideRightxSet == 0 || (leftsideRightxSet&(uint64(1)<<t)) != 0 {
					nn := gd.ArcIndex(i)
					_, success := traverseBackwards(b, row, col-1, nn, true, leftCol, gd)
					if success {
						b.SetCrossSetLetter(row, col, dir, tilemapping.MachineLetter(t))
					}
				}
			}
			if gd.IsEnd(i) {
				break
			}
		}
	}

	// Use hook sets for cross-set if we haven't computed it yet
	_ = backHookSet
	_ = frontHookSet
}
